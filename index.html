<!doctype html>
<html lang="ja">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<link rel="stylesheet" class="cachebuster" href="./css/style.css" type="text/css" />
	<link rel="shortcut icon" href="./favicon.ico" type="image/x-icon" />
	<title>らぢ助 - Radio Scheduler -</title>
	<link rel="manifest" href="./manifest.json" />
	<link rel="apple-touch-icon" sizes="512x512" href="./icon/icon512.png" />
	<link rel="apple-touch-icon" sizes="192x192" href="./icon/icon192.png" />
	<link rel="apple-touch-icon" sizes="180x180" href="./icon/icon180.png" />
	<link rel="apple-touch-icon" sizes="152x152" href="./icon/icon152.png" />
	<link rel="apple-touch-icon" sizes="120x120" href="./icon/icon120.png" />
	<meta name="mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="apple-mobile-web-app-title" content="ラジオの操作・予約再生が可能なアプリ「らぢ助 (Radio Scheduler)」です。" />
</head>

<body id="controller">

<header>

	<h1>Radio Scheduler</h1>
	<p>IP: <span id="this_ip">local</span></p>

</header>

<section class="card">

	<h2>チャンネル一覧</h2>

	<h3 id="area_name">area name</h3>

	<div class="station_list" id="station_list">
		<div class="station dummy blink"></div>
		<div class="station dummy blink"></div>
		<div class="station dummy blink"></div>
		<div class="station dummy blink"></div>
		<div class="station dummy blink"></div>
		<div class="station dummy blink"></div>
	</div>

</section>

<section class="control_panel">

	<div class="control_panel_set">

		<span id="play_info"></span>

		<span class="volume_ui">

			<svg class="icon_volume" viewBox="0 0 100 100">
				<path d="M24.34,21.52c-1.89,1.37-5.36,2.49-7.7,2.49H4.25c-2.34,0-4.25,1.91-4.25,4.25v43.38c0,2.34,1.91,4.25,4.25,4.25h12.4c2.34,0,5.8,1.12,7.7,2.49l26.26,19.03c1.89,1.37,3.44.58,3.44-1.76V4.25c0-2.34-1.55-3.13-3.44-1.76l-26.26,19.03Z"/>
				<pat d="M79.29,90.15c-1.02,0-2.02-.47-2.65-1.37-1.04-1.46-.7-3.49.76-4.53,11.09-7.9,17.72-20.73,17.72-34.33s-6.62-26.43-17.72-34.33c-1.46-1.04-1.8-3.07-.76-4.53,1.04-1.46,3.07-1.8,4.53-.76,12.8,9.11,20.45,23.93,20.45,39.62s-7.64,30.51-20.45,39.62c-.57.41-1.23.6-1.88.6Z"/>
				<path d="M71.08,78.6c-1.02,0-2.02-.47-2.65-1.37-1.04-1.46-.7-3.49.76-4.53,7.36-5.24,11.75-13.75,11.75-22.77s-4.39-17.53-11.75-22.77c-1.46-1.04-1.8-3.07-.76-4.53,1.04-1.46,3.07-1.8,4.53-.76,9.07,6.46,14.48,16.95,14.48,28.07s-5.41,21.61-14.48,28.07c-.57.41-1.23.6-1.88.6Z"/>
				<path d="M62.87,67.04c-1.02,0-2.02-.47-2.65-1.37-1.04-1.46-.7-3.49.76-4.53,3.62-2.58,5.79-6.77,5.79-11.22s-2.27-8.84-6.07-11.41c-1.49-1-1.88-3.02-.87-4.51,1-1.49,3.03-1.88,4.51-.87,5.59,3.78,8.93,10.06,8.93,16.8s-3.19,12.71-8.52,16.51c-.57.41-1.23.6-1.88.6Z"/>
			</svg>

			<input type="range" id="volume_range" name="volume" min="0" max="100" />

			<button id="radiko_stop">
				<svg viewBox="0 0 100 100" class="icon_stop"><rect width="100%" height="100%" rx="2" ry="2"/></svg>
			</button>

		</span>

	</div>

</section>

<section class="card">

	<h3>メンテナンス情報</h3>

	<div id="xml_info">公式からのお知らせを取得します。</div>

</section>

<section class="card">

	<h3>スケジュール管理</h3>

	<div class="schedule_list_box"><div id="schedule_list"></div></div>

</section>

<section class="card">

	<h3>音声ファイル管理</h3>

	<div id="audio_file_list">ファイルはまだ登録されていません。</div>
	<p id="upload_message">スケジュール再生に使用する音声ファイルをここで登録可能です。</p>
	<div id="upload">再生に使用したいファイルをこちらへドラッグアンドドロップしてください。(mp3ファイル限定)</div>

</section>

<div id="option_open"><span id="option_open_btn">・・・</span></div>

<section id="option_nemu_box">

	<div>
		<button onclick="location.href='./page/settings.html'" class="settings_link has_tip">
			<svg viewBox="0 0 512 512"><g><path class="st0" d="M502.325,307.303l-39.006-30.805c-6.215-4.908-9.665-12.429-9.668-20.348c0-0.084,0-0.168,0-0.252 c-0.014-7.936,3.44-15.478,9.667-20.396l39.007-30.806c8.933-7.055,12.093-19.185,7.737-29.701l-17.134-41.366 c-4.356-10.516-15.167-16.86-26.472-15.532l-49.366,5.8c-7.881,0.926-15.656-1.966-21.258-7.586 c-0.059-0.06-0.118-0.119-0.177-0.178c-5.597-5.602-8.476-13.36-7.552-21.225l5.799-49.363 c1.328-11.305-5.015-22.116-15.531-26.472L337.004,1.939c-10.516-4.356-22.646-1.196-29.701,7.736l-30.805,39.005 c-4.908,6.215-12.43,9.665-20.349,9.668c-0.084,0-0.168,0-0.252,0c-7.935,0.014-15.477-3.44-20.395-9.667L204.697,9.675 c-7.055-8.933-19.185-12.092-29.702-7.736L133.63,19.072c-10.516,4.356-16.86,15.167-15.532,26.473l5.799,49.366 c0.926,7.881-1.964,15.656-7.585,21.257c-0.059,0.059-0.118,0.118-0.178,0.178c-5.602,5.598-13.36,8.477-21.226,7.552 l-49.363-5.799c-11.305-1.328-22.116,5.015-26.472,15.531L1.939,174.996c-4.356,10.516-1.196,22.646,7.736,29.701l39.006,30.805 c6.215,4.908,9.665,12.429,9.668,20.348c0,0.084,0,0.167,0,0.251c0.014,7.935-3.44,15.477-9.667,20.395L9.675,307.303 c-8.933,7.055-12.092,19.185-7.736,29.701l17.134,41.365c4.356,10.516,15.168,16.86,26.472,15.532l49.366-5.799 c7.882-0.926,15.656,1.965,21.258,7.586c0.059,0.059,0.118,0.119,0.178,0.178c5.597,5.603,8.476,13.36,7.552,21.226l-5.799,49.364 c-1.328,11.305,5.015,22.116,15.532,26.472l41.366,17.134c10.516,4.356,22.646,1.196,29.701-7.736l30.804-39.005 c4.908-6.215,12.43-9.665,20.348-9.669c0.084,0,0.168,0,0.251,0c7.936-0.014,15.478,3.44,20.396,9.667l30.806,39.007 c7.055,8.933,19.185,12.093,29.701,7.736l41.366-17.134c10.516-4.356,16.86-15.168,15.532-26.472l-5.8-49.366 c-0.926-7.881,1.965-15.656,7.586-21.257c0.059-0.059,0.119-0.119,0.178-0.178c5.602-5.597,13.36-8.476,21.225-7.552l49.364,5.799 c11.305,1.328,22.117-5.015,26.472-15.531l17.134-41.365C514.418,326.488,511.258,314.358,502.325,307.303z M281.292,329.698 c-39.68,16.436-85.172-2.407-101.607-42.087c-16.436-39.68,2.407-85.171,42.087-101.608c39.68-16.436,85.172,2.407,101.608,42.088 C339.815,267.771,320.972,313.262,281.292,329.698z"></path></g></svg>
			<span class="tip">設定ページへ</span>
		</button>
		<button id="super_reload" class="has_tip">
			<svg viewBox="0 0 100 101"><path class="cls-1" d="M51.02,3.5c-10.67,0-20.79,3.5-29.08,9.94l-6.97-6.97c-.51-.51-1.08-.36-1.27.34l-7.49,27.94c-.19.7.23,1.12.93.93l27.94-7.49c.7-.19.85-.76.34-1.27l-6.35-6.35c6.35-4.6,13.95-7.08,21.94-7.08,20.69,0,37.52,16.83,37.52,37.52,0,2.76,2.24,5,5,5s5-2.24,5-5c0-26.2-21.32-47.52-47.52-47.52Z"/><path class="cls-1" d="M94.89,66.35l-27.94,7.49c-.7.19-.85.76-.34,1.27l6.35,6.35c-6.35,4.59-13.95,7.08-21.94,7.08-20.69,0-37.52-16.83-37.52-37.52,0-2.76-2.24-5-5-5s-5,2.24-5,5c0,26.2,21.32,47.52,47.52,47.52,10.67,0,20.79-3.5,29.08-9.94l6.97,6.97c.51.51,1.08.36,1.27-.34l7.49-27.94c.19-.7-.23-1.12-.93-.93Z"/></svg>
			<span class="tip">ページの再読み込み</span>
		</button>
		<button id="system_reboot" class="has_tip">
			<svg viewBox="0 0 110 100"><path class="cls-1" d="M51.02,53.02c-2.76,0-5-2.24-5-5V7c0-2.76,2.24-5,5-5s5,2.24,5,5v41.02c0,2.76-2.24,5-5,5Z"/><path class="cls-1" d="M111.1,69.3l-8.43-31.48c-.46-1.73-1.81-3.07-3.54-3.54-1.72-.46-3.57.03-4.83,1.29l-23.04,23.04c-1.95,1.95-1.95,5.12,0,7.07,1.95,1.95,5.12,1.95,7.07,0l9.9-9.9c-2.36,18.44-18.14,32.74-37.2,32.74-20.69,0-37.52-16.83-37.52-37.52,0-10.02,3.9-19.44,10.99-26.53,1.95-1.95,1.95-5.12,0-7.07-1.95-1.95-5.12-1.95-7.07,0C8.45,26.4,3.5,38.33,3.5,51.02c0,26.2,21.32,47.52,47.52,47.52,23.58,0,43.2-17.27,46.89-39.83l3.53,13.18c.6,2.23,2.62,3.71,4.83,3.71.43,0,.86-.06,1.3-.17,2.67-.71,4.25-3.46,3.54-6.12Z"/></svg>
			<span class="tip">端末を再起動</span>
		</button>
		<button id="system_power_off" class="has_tip">
			<svg viewBox="0 0 100 100"><path d="M51.02,53.02c-2.76,0-5-2.24-5-5V7c0-2.76,2.24-5,5-5s5,2.24,5,5v41.02c0,2.76-2.24,5-5,5Z"/><path d="M51.02,98.54c-26.2,0-47.52-21.32-47.52-47.52C3.5,31.36,15.86,13.49,34.25,6.55c2.59-.98,5.47.33,6.44,2.91.98,2.58-.33,5.47-2.91,6.44-14.52,5.48-24.27,19.59-24.27,35.12,0,20.69,16.83,37.52,37.52,37.52s37.52-16.83,37.52-37.52c0-15.52-9.75-29.64-24.27-35.12-2.58-.97-3.89-3.86-2.91-6.44.97-2.58,3.86-3.89,6.44-2.91,18.39,6.94,30.74,24.81,30.74,44.47,0,26.2-21.32,47.52-47.52,47.52Z"/></svg>
			<span class="tip">端末の電源オフ</span>
		</button>
	</div>

</section>

<footer>
	<p class="copy">らぢ助 - Radio Scheduler -<br />&copy; 2025 <a href="https://weblabyrinth.net" target="_blank">WebLabyrinth</a></p>
</footer>

<div id="message_box" class="fade">
	<div id="message_bg"></div>
	<div id="message_display">* message *</div>
</div>

<script type="module">

	// スケジュール関係

	const schedule_list = document.getElementById("schedule_list");

	// ファイルアップロード関係

	const um_output = document.getElementById("upload_message");
	const list_output = document.getElementById("audio_file_list");
	const drop_zone_element = document.getElementById("upload");// ここに放り込むとアップロードされる
	let available_audio = new Array();
	let list_audio_play = false;

	// サービスワーカー関係

	let modules;

	// サービスワーカーからメッセージを受信したときに使用する関数

	function serviceworker_Message_processing(event) {

		console.log("@ [message] Received from Service Worker");

		// キャッシュの更新通知
		// キャッシュバスターを実行してリロードメッセージを表示

		if (event.data.type === "CACHE_UPDATE_COMPLETE") {
			css_js_cachebuster(event.data.version, "Cache update complete");
			modules.fnc.msg_fade_in( event.data.message + '<br />反映を行うためにページのリロードを行ってください。<br /><input type="button" value="リロード" onclick="window.location.reload();" />' );
		}

	}

	// 電源操作関係で使用
	// 経過秒数を表示させる

	let device_started = false;

	function standby_time_display() {

		console.log("*** standby time display ***");

		let seconds = 0;

		const interval_id = setInterval(function() {

			seconds++;

			console.log(seconds);

			// device_started === true なら停止
			// 時間かかりすぎたら停止しておこう (5分目安)

			if ( seconds >= 300 ) {

				clearInterval(interval_id);// タイマー停止
				modules.fnc.msg_fade_in("起動に時間がかかりすぎているようです。<br />端末の電源を確認してください。");

			} else if ( device_started === true ) {

				clearInterval(interval_id);// タイマー停止
				modules.fnc.msg_fade_out();

			} else {

				modules.fnc.msg_fade_in("起動待機中: " + seconds + "秒経過");

			}

		}, 1000);

	}

	// ページ読み込み時や電源操作時に実行する
	// 端末が起動しているかの確認と復帰までの待機
	// 端末が完全に終了する前に実行すると fetch が反応してしまい貯め
	// 電源操作後30秒ほど待機してから実行する事

	async function check_server_alive(retries = 5) {

		console.log("### サーバー生存確認中: " + retries);

		for ( let i = 0; i < retries; i++ ) {

			try {

				// ログファイルを読み込んで、端末が動いているかの確認とする。
				// method: "HEAD", cache: "no-store" を使用しているので
				// fetch_template() は使用しない

				const response = await fetch(
					"./log/radiko_play.log",
					{ method: "HEAD", cache: "no-store" }
				);

				if ( response.ok ) {
					device_started = true;// サーバー起動フラグ
					return true;// サーバ応答あり
				}

			} catch (event) {
				console.log("応答なし (" + i + ") リトライ");
			}

			await new Promise(resolve => setTimeout(resolve, 3000));// 一定待機してリトライ

		}

		// サーバーにアクセスできない状態の場合はオフラインメッセージを表示

		document.getElementById("controller").innerHTML = modules.tol.change_to_offline_view();

		clearInterval( si_array.shift() );// 音声ファイル監視を停止

		return false;// ここまで来たら全て失敗

	}

	// ラジオ局の情報一式を収納する場所

	let stations = new Array();

	// 再生中の背景を一括でクリアにする

	function stations_bg_initialization() {

		// 再生中のアニメーションアイコンの非表示

		const process_e_array = document.getElementsByClassName("in_process");

		for ( let n = 0; n < process_e_array.length; n++ ) {
			process_e_array[n].style.display = "none";
		}

		// 背景色削除

		const station_e_array = document.getElementsByClassName("station");

		for ( let n = 0; n < station_e_array.length; n++ ) {
			station_e_array[n].style.backgroundColor = null;
		}

		// ボタンのスタイル削除

		const play_btn_e_array = document.getElementsByClassName("radiko_ch");

		for ( let n = 0; n < play_btn_e_array.length; n++ ) {
			play_btn_e_array[n].removeAttribute("style");
		}

	}

	// 局のIDから諸情報を検索して表示を行う関数
	// 一覧から再生中の局の領域への変更も行ってみる
	// 局のIDを引数に入れれば動くようにしてみる

	const radiko_stop = document.getElementById("radiko_stop");

	function show_playing_info(station_id) {

		//console.log(playback_status_object.channel);

		let this_name = "";
		let this_image = "";
		let hit_id = false;// チャンネルIDがヒットしたか否か

		// 再生中の場合は手前でエリアIDから取得した各チャンネルの情報の中から該当するチャンネル名やサムネイルを拾い上げる

		for ( let n = 0; n < stations.length; n++ ) {

			if ( stations[n]["id"] == station_id ) {
				this_name = stations[n]["name"];
				this_image = stations[n]["logo"];
				hit_id = true;
			}

		}

		if ( hit_id ) {

			// 受け取ったIDの情報が stations 内に存在した場合

			// チャンネル情報をフッターに表示

			const html = '<span class="station_logo"><img src="' + this_image + '" alt="' + this_name + '" /></span><span class="station_name">' + this_name + '</span>';

			document.getElementById("play_info").innerHTML = html;

			// チャンネル一覧で再生済みとなっている要素の背景を初期化

			stations_bg_initialization();

			// 再生中のチャンネル要素の背景を変更

			console.log("*** Currently playing: " + station_id + " ***");

			const this_box = document.getElementById( station_id + "_box" );

			this_box.style.backgroundColor = "#999";

			// 再生中のチャンネル要素にアニメーションを表示

			const this_process = this_box.querySelector(".in_process");// 親要素内の .in_process を取得
			this_process.style.display = "flex";// .in_process 表示

			// 該当チャンネルのボタン class="radiko_ch" をクリック不可に変更
			// 色なども変更

			const this_play_btn = this_box.getElementsByClassName("radiko_ch");
			this_play_btn[0].style.pointerEvents = "none";
			this_play_btn[0].style.opacity = "0.15";
			this_play_btn[0].style.background = "#fff";
			this_play_btn[0].style.color = "#000";

			// 停止ボタンは表示させる

			radiko_stop.style.display = "inline-block";

		} else {

			// 受け取ったIDの情報が stations 内に存在しなかった場合

			init_play_info();

		}

	}

	// 停止した場合の処理
	// フッターの局情報と一覧を初期化する

	function init_play_info() {

		// チャンネル一覧で再生済みとなっている要素の背景を初期化

		stations_bg_initialization();

		// 停止中という表示

		document.getElementById("play_info").innerHTML = '<span class="station_name">只今ラジオは停止中です</span>';

		// 停止ボタンは非表示

		radiko_stop.style.display = "none";

	}

	// radiko 現在再生中か・どの局を再生中かを確認する
	// この関数はモジュール読み込み前に実行する場合があるため
	// fetch_template は使用せず fetch で実行する

	async function radiko_status_check() {

		//const playback_status_object = await modules.tol.fetch_template("./php/radiko_playback_status.php", "");
		const playback_status_json = await fetch("./php/radiko_playback_status.php");
		const playback_status_object = await playback_status_json.json();

		// 再生している時としていない場合の表示切替

		if ( playback_status_object.status === "playing" ) {
			const this_id = playback_status_object.channel;
			show_playing_info(this_id);
		} else {
			init_play_info();
		}

	}

	// radiko 停止関数

	async function stop_request() {

		// 停止に伴う表示の初期化
		// 厳密に考えると停止のコールバックを受け取ってから
		// 初期化を行った方が良いが可能なのかな？

		init_play_info();

		const result = await modules.tol.fetch_template("./php/player_stop.php", "");

		let result_value = false;

		if ( result == "stopped" ) {

			init_play_info();// 停止に伴う表示の初期化

			console.log("Stopped successfully");

			result_value = true;

		} else {

			// 停止できなかった場合
			// 無いと思うが停止できなかった場合の処理も考える必要はあるかも
			// 必要に応じて「再生停止に失敗したので、後に続く処理を停止しました。時間をおいて再度実行を試みてください。」の様なメッセージを表示させた方が良いかもしれない。

			console.log("[!] Stop failed...");

		}

		return result_value;

	}

	// クリックで radiko 再生および停止

	document.addEventListener("click", async function(event) {

		//console.log(event);

		// radiko 再生 > パラメータで局のIDを送る
		// class="radiko_ch" をクリックで php へ id を送信

		if ( event.target.classList.contains("radiko_ch") ) {

			// クリックした再生ボタン要素と兄弟要素である in_process を非表示から表示へ切り替える

			const station_box = event.target.closest(".station");// 親要素
			const in_process = station_box.querySelector(".in_process");// 親要素内の .in_process を取得

			if (in_process) {
				in_process.style.display = "flex";// .in_process 表示
			}

			// チャンネル情報を取り出して php へ送る

			let this_ch_id = event.target.dataset.ch;

			const params = new URLSearchParams({
				cmd: "play",
				channel: this_ch_id
			});

			const query_string = new URLSearchParams(params).toString();
			const object = await modules.tol.fetch_template("./php/player_radiko_play.php", query_string);

			// object.result > success なら再生成功

			if ( object.result == "success" ) {

				// 再生結果に伴う表示切り替え処理

				const this_channel = object.channel;

				// 再生情報をフッターや一覧にも反映

				show_playing_info(this_ch_id);

				// 再生しているメッセージを表示し、少し待ってからメッセージ非表示させる。

				modules.fnc.msg_fade_in("只今再生中です ( Channel ID: " + this_ch_id + " )");
				await modules.fnc.js_sleep(3000);
				modules.fnc.msg_fade_out();

			} else {

				modules.fnc.msg_fade_in("再生に失敗しました ( Channel ID: " + this_ch_id + " )");

			}

		}

		if ( event.target.classList.contains("in_process") ) {
			const result = await stop_request();
		}

	});

	// radiko 停止 ( .in_process クリックでも停止させます )

	radiko_stop.addEventListener("click", async function() {
		const result = await stop_request();
	});

	// フッター側の音量調節ツマミ

	const volume_range = document.getElementById("volume_range");

	// 音量表示処理

	function f_volume_display(value) {

		//console.log(value);

		volume_range.style.background = "linear-gradient(to right, #eee 0%, #eee " + value + "%, #666 " + value + "%, #666 100%)";

	}

	// ツマミ変更時に値を取得

	volume_range.addEventListener("change",  async function(event) {

		//console.log("Current value:", event.target.value);

		const params = new URLSearchParams({
			v: event.target.value
		});

		const query_string = new URLSearchParams(params).toString();
		const volume = await modules.tol.fetch_template("./php/volume_set.php", query_string);

		//console.log(volume);

		f_volume_display(volume);

	});

	// 音声ファイル再生時に各ボタンを調整
	// 再生中は音声ファイル削除ボタンは無効

	function audio_play_button_control(filename) {

		const play_btn_array = document.getElementsByClassName("audio_play");
		const del_btn_array = document.getElementsByClassName("audio_del");

		for ( let m = 0; m < del_btn_array.length; m++ ) {
			del_btn_array[m].style.opacity = "0.5";
			del_btn_array[m].style.pointerEvents = "none";
		}

		for ( let n = 0; n < play_btn_array.length; n++ ) {

			const this_filename = play_btn_array[n].dataset.name;

			if ( this_filename === filename ) {
				play_btn_array[n].style.backgroundColor = "#fff";
				play_btn_array[n].style.opacity = "1";
				list_audio_play = true;
				um_output.innerHTML = '<spam class="playing"></spam>' + this_filename + " (再度 Play ボタンで停止)";
			}

		}

	}

	// 音声ファイル停止時に各ボタンを調整
	// 音声ファイル削除ボタンは無効を解除
	// 再生ボタンのスタイルを初期化

	function audio_stop_button_control() {

		clearInterval( si_array.shift() );

		const play_btn_array = document.getElementsByClassName("audio_play");
		const del_btn_array = document.getElementsByClassName("audio_del");

		for ( let n = 0; n < play_btn_array.length; n++ ) {
			play_btn_array[n].style.backgroundColor = null;
			play_btn_array[n].style.opacity = null;
		}

		for ( let m = 0; m < del_btn_array.length; m++ ) {
			del_btn_array[m].style.opacity = null;
			del_btn_array[m].style.pointerEvents = null;
		}

		list_audio_play = false;
		um_output.innerHTML = "スケジュール再生に使用する音声ファイルをここで登録可能です。";

	}

	// 端末を再起動

	const system_reboot = document.getElementById("system_reboot");

	system_reboot.addEventListener("click", async function() {

		device_started = false;// 端末停止フラグ
		let stop_playing = false;// 再生停止フラグ

		if ( confirm("端末の再起動を行います。") ) {

			// 再生中なら停止処理

			const result = await stop_request();

			// 停止出来たら再起動を実行

			if (result) {

				const message = await modules.tol.fetch_template("./php/pow_reboot.php", "");

				modules.fnc.msg_fade_in(message);

				// 少し待機してから...

				//await modules.fnc.js_sleep(2000);

				// 待機中のカウントメッセージを表示

				await standby_time_display();

				// 更に少し待機してから...

				//await modules.fnc.js_sleep(2300);

				// 端末の起動確認
				// Raspberry Pi Zero 2 W は、OS のシャットダウンから再起動後
				// wifi のネットワークが安定するまでの時間を含めると、約30秒は必要と言われている。
				// 段階的にメッセージを表示させてもいいかもしれない

				const alive = await check_server_alive(15);// 引数は試行回数

				if ( alive ) {

					console.log("再起動完了 reboot.addEventListener");
					//modules.fnc.msg_fade_out();
					modules.fnc.msg_fade_in("再起動が完了しました。");

					await modules.fnc.js_sleep(3000);

					modules.fnc.msg_fade_out();

				} else {

					console.log("再起動後のコールバックに失敗");
					modules.fnc.msg_fade_in("起動チェックエラー<br />サーバーが起動していない可能性があります。");

				}

			}

		}

	});

	// 音声ファイルの再生状況を監視する関数
	// 戻り値で player_state.state === true なら再生中
	// player_state.state === false なら停止

	let si_array = new Array();

	async function check_audio() {

		const player_state = await modules.tol.fetch_template("./php/audio_check.php", "");

		//console.log(player_state);

		const play_btn_array = document.getElementsByClassName("audio_play");
		const del_btn_array = document.getElementsByClassName("audio_del");

		if ( player_state.state === true ) {// 再生中だった場合は停止
			audio_play_button_control(player_state.file);
		} else if ( player_state.state === false ) {// 停止中だった場合は再生
			audio_stop_button_control();
		}

	}

	// 端末をシャットダウン

	const system_power_off = document.getElementById("system_power_off");

	system_power_off.addEventListener("click", async function() {

		if ( confirm("端末のシャットダウンを行います。") ) {

			// 再生中なら停止処理

			const result = await stop_request();

			// 停止出来たらシャットダウンを実行

			if (result) {

				const message = await modules.tol.fetch_template("./php/pow_off.php", "");

				modules.fnc.msg_fade_in(message);

			}

		}

	});

	// キャッシュバスター
	// css ファイルを ***.css?v=*** の様にパラメータ付きの形式に置き換える
	// 複数回実行すると ***.css?v=123?v=123?v=123 の様にパラメータが増え続けるので
	// オリジナルのファイルに整形を行ってから再度パラメータを付与している

	function css_js_cachebuster(version, location = "Unknown") {

		const cb_elements = document.getElementsByClassName("cachebuster");

		//console.log( "class: cachebuster ... " + cb_elements.length );
		//console.log("+ version: " + version);

		for ( let n = 0; n < cb_elements.length; n++ ) {

			const old_link = cb_elements[n];

			// 元のhrefを取得
			// ここでは css のみの更新とする
			// js ファイルをここでキャッシュバスターするとエラーの原因となるので modules へインポートすること

			const old_link_href = old_link.href;
			const old_link_split = old_link_href.split("?");
			const original_href = old_link_split[0];

			// 新しいlink要素を作成

			const new_link = document.createElement("link");

			new_link.rel = "stylesheet";
			new_link.className = "cachebuster";
			new_link.type = "text/css";

			new_link.onload = function() {
				console.log("- [" + location + "] Cache Buster (CSS): " + new_link.href);
			};

			new_link.href = original_href + "?v=" + version;

			// 古いlink要素へ置き換え

			old_link.parentNode.replaceChild(new_link, old_link);

		}

	}

	// 受け取った URL で fetch を実行し、文字列を返す。
	// オフラインモードの場合、またはタイムアウトした場合等は相応の文字列を返す

	async function fetch_get_value(url, options = {}, timeout = 5000) {

		//console.log("- fetch_get_value() 2: " + url);

		const controller = new AbortController();
		const id = setTimeout(() => controller.abort(), timeout);

		options.signal = controller.signal;

		try {

			const response = await fetch(url, options);

			//console.log(response);

			clearTimeout(id);

			if ( ! response.ok ) {

				// Service Worker が返す "Offline and not cached" を確認

				if ( response.status === 503 ) {

					const text = await response.text();

					if (text === "Offline and not cached") {
						return "offline";
					}

				}

				return "http-error: " + response.status;

			}

			const response_text = await response.text();

			return response_text;

		} catch (error) {

			clearTimeout(id);

			if (error.name === "AbortError") {
				return "timeout";
			} else {
				return "network-error";
			}

		}

	}

	// 読み込み時に実行する関数
	// 現在のキャッシュ値を indexedDB から取得する関数
	// ここで取得した値を使用して import の JS ファイルをキャッシュバスターする
	// 取得のみなの事と、細かく書くと共有部分のコードがもったいないので
	// ここでは簡素な内容で取得させている

	async function load_idb_cache_version() {

		const object = await new Promise( function(resolve, reject) {

			const idb_open = indexedDB.open("radiko_info", 1);

			// 成功時に実行

			idb_open.onsuccess = function(event) {

				const db = event.target.result;
				const transaction = db.transaction("radiko", "readonly");
				const db_store = transaction.objectStore("radiko");
				const value_get_request = db_store.get("version");

				value_get_request.onsuccess = function(event) {
					resolve(event);
				}

				value_get_request.onerror = function(event) {
					resolve(event);
				}

			};

			idb_open.onerror = function(error) {
				resolve(error);
			};

			// indexedDB のバージョンが変更された場合に実行 (新規作成時含む)
			// このタイミングで必要な情報を保存する

			idb_open.onupgradeneeded = function(error) {

				let db = event.target.result;
				let table_object = db.createObjectStore("radiko", { keyPath: "name" });

				let value_get_request = table_object.getAll();

				value_get_request.onsuccess = function(event) {
					resolve(event);
				}

				value_get_request.onerror = function(event) {
					resolve(event);
				}

				db.close();// 接続を解除する

			};

		});

		//console.log(object);

		// バージョン情報が保存されていない場合は 1 とする

		if ( object?.target?.result?.value !== undefined ) {
			return object.target.result.value;
		} else {
			return 1;
		}

	}

	// 読み込むモジュールをキャッシュバスターで import()

	async function load_import_module(location = "Unknown") {

		let cv = await load_idb_cache_version();

		console.log("- [" + location + "] load_import_module(): " + cv);

		// js の import

		const import_up = await import("./js/tool.js?v=" + cv);
		const import_fnc = await import("./js/function_set.js?v=" + cv);
		const import_idb = await import("./js/indexeddb.js?v=" + cv);

		const return_object = {
			"tol": import_up,// tool.js
			"fnc": import_fnc,// function_set.js
			"idb": import_idb,// indexeddb.js
			"cv": cv// キャッシュバージョン
		};

		//console.log(return_object);

		//return_object.fnc.test_func();

		return return_object;

	}

	// -------------------------------------------------------
	// ページ読込時に実行
	// 1. IndexedDB の読み込み
	// 2-1. サービスワーカーの起動
	// 2-2. バージョン（キャッシュ）の更新があった場合は再起動通知
	// 3. 端末の生存確認
	// 4. 地域IDとチャンネル情報の取得・更新
	// 5. 音量状態の取得
	// 6. チャンネル再生状況の取得
	// 7. 地域IDからお知らせ情報を取得
	// -------------------------------------------------------

	window.onload = async function() {

		console.log("* * * Load setup start * * *");

		// [処理1]
		// indexedDB から現在のキャッシュバージョンを取得

		// 使用するモジュールをインポートする (仮インポートのシチュエーションあり)

		modules = await load_import_module("load 1");

		// 端末の生存確認 1 ( PHP からサーバーの IP を確認 )

		const server_ip_json = await fetch_get_value("./php/server.php", {cache: "no-store"}, 3000);

		let server_access = false;

		try {

			JSON.parse(server_ip_json);

			// json を受け取れた場合 -> IP 表示

			const server_ip_res = JSON.parse(server_ip_json);

			//console.log(server_ip_res);

			document.getElementById("this_ip").innerText = server_ip_res.ip;

			server_access = true;// サーバーにアクセスできた

		} catch (error) {

			// json ではなく文字列だった -> オフラインです

			console.log(error);

			// サーバーにアクセスできない状態の場合はオフラインメッセージを表示

			document.getElementById("controller").innerHTML = modules.tol.change_to_offline_view();

			return;// サーバーに繋がってないので終了

		}

		// 端末の生存確認 2

		const idb_cv = modules.cv;// キャッシュ値も含まれている

		// 読込時のバージョンを保存しておく
		// サービスワーカー更新時にバージョンが変わったことを
		// 判断させるために使用する

		const starting_version = idb_cv;

		// 静的リンクの CSS ファイルと JS ファイルについて
		// キャッシュ値を使用してキャッシュバスターを実施 (静的にリンクしている部分)
		// キャッシュ値を取得できなかった場合はそのまま

		// キャッシュバスター実行 (css, js)

		css_js_cachebuster(idb_cv, "load 1");

		// fetch でサービスワーカーの最新バージョンを確認
		// オフラインや例外的エラーが出た場合は indexedDB で保存された値を使用
		// バージョンが受け取れた場合はその値を使用する
		// 疑似オフラインの設定を有効にしていても
		// それはサービスワーカーがまだ有効になっていない状態であれば
		// インターネットに繋がっている状態であればバージョンは取得可能（のはず）

		const fetch_cv_value = await fetch_get_value("./cv.txt", {cache: "no-store"}, 4000);

		let latest_version;

		console.log("* fetch_cv_value: " + fetch_cv_value);

		if ( fetch_cv_value == "offline" || fetch_cv_value == "timeout" || fetch_cv_value == "network-error" ) {

			// オフラインなら indecedDB の値を使用する

			latest_version = idb_cv;// indexedDB

			// だけどオフライン状態である表示に切り替える

			document.getElementById("controller").innerHTML = modules.tol.change_to_offline_view();

			clearInterval( si_array.shift() );// 音声ファイル監視を停止

		} else {

			// キャッシュバージョン値を取得できたなら、その値を使用する。

			latest_version = fetch_cv_value;// fetch value

		}

		// 使用するモジュールを再度インポートする

		// 少し上で indexedDB にのバージョン値に更新が入り
		// キャッシュバージョンが明確になったため
		// 存在する（であろう）パラメータ付きで再度読み込みして上書き

		modules = await load_import_module("load 2");

		// 再度取得したバージョンで再度キャッシュバスター実行

		console.log("* latest_version: " + latest_version);

		css_js_cachebuster(latest_version, "load 2");

		// IndexedDB から保存情報の確認

		const idb_object = await modules.idb.get_idb_object();

		//console.log(idb_object);

		const idb_id = modules.idb.idb_finding_Values(idb_object, "id");
		const idb_stations = modules.idb.idb_finding_Values(idb_object, "stations");
		const idb_name = modules.idb.idb_finding_Values(idb_object, "name");
		const idb_time = modules.idb.idb_finding_Values(idb_object, "time");

		// キャッシュバスターでキャッシュ内のファイルを使用させる

		css_js_cachebuster(latest_version, "Window onLoad");

		// サービスワーカーインストールでキャッシュを保存
		// ?cv= でサービスワーカーへバージョンを渡す

		if ("serviceWorker" in navigator) {

			// サービスワーカーから受信するメッセージ用イベントの登録

			navigator.serviceWorker.addEventListener("message", function (event) {
				serviceworker_Message_processing(event);
			});

			// サービスワーカーの登録開始

			navigator.serviceWorker.register(
				"./sw.js?cv=" + latest_version,
				{scope: "./", type: "module"}
			).then(function(registration) {
				console.log("ServiceWorker を登録しました: [scope] ", registration.scope);
				//console.log("ServiceWorker registration successful with scope: ", registration);
			}).catch(function(error) {
				console.log("ServiceWorker の登録に失敗しました: ", error);
			});

			// サービスワーカーの controller 切り替えを明示的に待ってリロードを促す
			// iOS ではサービスワーカー更新時に statechange イベントの installed 判定で
			// リロードを促すとリロードの案内がループする可能性がある

/*			navigator.serviceWorker.addEventListener("controllerchange", async function(event) {

				//let modules = await load_import_module("controllerchange");// 使用するモジュールをインポートする

				console.log("* controllerchange *");
				//console.log(event);

				// indexedDB内のバージョンと比較
				// バージョンが異なる場合は更新とみなしてリロードを促す

				const change_idb_object = await modules.idb.get_idb_object();
				const change_cache_version = modules.idb.idb_finding_Values(change_idb_object, "version");

				console.log("change_cache_version: " + change_cache_version);
				console.log("starting_version: " + starting_version);

				if ( Number(starting_version) != Number(change_cache_version) ) {

					// キャッシュバスターを実行

					css_js_cachebuster(change_cache_version, "Change Cache Version");

					// リロードのメッセージ

					//modules.fnc.msg_fade_in('サービスワーカーが更新されました。<br />反映を行うためにページのリロードを行ってください。<br /><input type="button" value="リロード" onclick="window.location.reload();" />');

				}

			});*/

		}

		modules.fnc.msg_fade_in("端末を確認中");

		const alive = check_server_alive(1);

		if ( alive ) {

			//console.log("サーバーは起動しています");
			modules.fnc.msg_fade_out();

		} else {

			modules.fnc.msg_fade_in("起動チェックエラー<br />端末の電源を確認してください。");

			return;// ここで終わり

			// このページが表示されるなら本来端末は起動しているが、念のための処理になる。
			// PWA化させてキャッシュ保存をさせたら、ここの処理は有効になると思う。

		}

		let region = false;

		// id と charray と name 各値の有無で判断
		// 上記項目が無い場合は radiko api からエリアIDとチャンネル情報を取得
		// その後に各 IndexedDB のキーへ保存を行う
		// id: エリアID , charray: チャンネル情報配列 , name: エリア名
		// また IndexedDB に保存させる期限が過ぎた場合も再取得を行う

		// 条件 1

		const conditions_a = ( typeof idb_id === "string" && idb_id !== "" ) &&
			( Array.isArray(idb_stations) && idb_stations.length > 0 ) &&
			( typeof idb_name === "string" && idb_name !== "" )
		;

		// 条件 2

		const conditions_b = ( Number(idb_time) + (7 * 24 * 60 * 60 * 1000) ) > Date.now();

		// 取得した情報と条件を比較

		if ( conditions_a || conditions_b ) {

			console.log("チャンネル情報が保存されています。");

			// チャンネル情報 stations に代入

			stations = idb_stations;

			// 地域ID を保存 (メンテナンス情報取得用)

			region = idb_id;

			// 保存された情報からリスト生成と出力

			document.getElementById("area_name").innerHTML = idb_name;
			document.getElementById("station_list").innerHTML = modules.fnc.generate_channels_html(stations);

			// チャンネル情報が保存されている場合はスケジュール管理UIも表示

			update_schedule_audio_html();

		} else {

			modules.fnc.msg_fade_in("チャンネル情報の取得中です。");

			// エリアID からラジオ局一覧を取得する
			// チャンネル情報を一緒に取得する

			const stations_object = await modules.tol.fetch_template("./php/get_list_stations.php", "");

			//console.log(stations_object);

			// 失敗した場合は stations_object.stations が空の配列

			if ( stations_object.stations.length !== 0 ) {

				modules.fnc.msg_fade_in("取得成功");

				// IdexedDB へ各値を保存する

				await modules.idb.update_indexeddb("id", stations_object.id);
				await modules.idb.update_indexeddb("stations", stations_object.stations);
				await modules.idb.update_indexeddb("name", stations_object.area_b);
				await modules.idb.update_indexeddb("time", Date.now());

				// チャンネル情報 stations に代入

				stations = stations_object.stations;

				// 地域ID を保存 (メンテナンス情報取得用)

				region = stations_object.id;

				// 取得した情報からリスト生成と出力

				document.getElementById("area_name").innerHTML = stations_object.area_b;
				document.getElementById("station_list").innerHTML = modules.fnc.generate_channels_html(stations);

				// チャンネル情報が保存されたのでスケジュール管理UIも表示

				update_schedule_audio_html();

			} else {

				//console.log("取得失敗");
				modules.fnc.msg_fade_in("チャンネル情報の取得に失敗しました。");

				// チャンネル情報が無いとスケジュールは組めない

				schedule_list.innerHTML = "<p>チャンネル情報を取得する必要があります。</p>";

			}

		}

		// 音量取得 PHP 経由でコマンドを実行して取得

		const current_volume = await modules.tol.fetch_template("./php/volume_get.php", "");

		//console.log(current_volume);

		f_volume_display(current_volume);
		volume_range.value = current_volume;

		// 現在再生中か・どの局を再生中かを確認する

		await radiko_status_check();

		// 音声ファイルが再生中か監視開始

		si_array.push( setInterval(check_audio, 2000) );

		// 地域ID からお知らせ情報を取得する

		//console.log("地域ID: " + region);

		const maintenance_params = new URLSearchParams({
			area: region
		});

		const maintenance_string = new URLSearchParams(maintenance_params).toString();
		const maintenance_object = await modules.tol.fetch_template("./php/maintenance_xml_analysis.php", maintenance_string);

		//console.log(maintenance_object);

		let xml_info_html = "";

		if ( maintenance_object.info.length > 0 ) {

			const info_object = maintenance_object.info;

			for ( let n = 0; n < info_object.length; n++ ) {

				xml_info_html += '<div class="info_set">';
				xml_info_html += '<p class="info_title">' + info_object[n]["title"] + '</p>';
				xml_info_html += '<p class="info_body">' + info_object[n]["body"] + '</p>';
				xml_info_html += '</div>';

			}

		}

		// 整形したお知らせ情報を表示

		document.getElementById("xml_info").innerHTML = xml_info_html;

		// クリックでお知らせ項目を開閉

		document.addEventListener("click", async function(event) {

			//console.log(event);

			if ( event.target.classList.contains("info_set") ) {

				// クリック .info_set の子要素を取得

				const child_nodes = event.target.children;

				// 子要素の .info_body を探す

				for ( let n = 0; n < child_nodes.length; n++ ) {

					const child_node = child_nodes[n];

					if ( child_node.classList.contains("info_body") ) {
						child_node.classList.toggle("is_open");
					}

				}

			}

		});

	};

	// オプションメニューの開閉

	const option_open_btn = document.getElementById("option_open_btn");
	const option_nemu_box = document.getElementById("option_nemu_box");

	option_open_btn.addEventListener("click", async function(event) {
		option_nemu_box.classList.toggle("is_open");
	});

	// スケジュール管理用 UI と音声ファイル関係の html を更新する関数
	// 1. スケジュール情報を確認
	// 2. 最新の音声ファイル情報に更新
	// 3. スケジュール管理 UI の一覧を更新

	async function update_schedule_audio_html() {

		// 保存されているスケジュール情報を取得

		const schedule_object = await modules.tol.fetch_template("./php/schedule_get.php", "");

		//console.log(schedule_object);

		// 保存されている音声ファイルを変数に保存し、一覧用の html も表示させる

		available_audio = await modules.tol.get_audio_list(list_output);

		// スケジュール関係の html を更新

		schedule_list.innerHTML = modules.tol.generate_schedule_list_html(schedule_object, stations, available_audio);

		// デフォルトでは repeat は false のため week_set は非表示にしておく

		document.getElementById("week_set").style.display = "none";

		// 同じく action は play のため audio も非表示とする

		document.getElementById("audio_set").style.display = "none";

		// time イベントの登録
		// time に変化があるごとに発火 > submit の表示 / 非表示

		document.getElementById("set_time").addEventListener("change", function(event) {

			if ( event.target.value !== "" ) {
				document.getElementById("submit_set").style.display = "Block";
			} else {
				document.getElementById("submit_set").style.display = "none";
			}

		});

		// action イベントの登録
		// action に変化があるごとに発火 > channel の表示 / 非表示

		document.querySelectorAll('input[name="action"]').forEach( function(radio) {
			radio.addEventListener("change", function(event) {

				if ( event.target.value === "play" ) {
					document.getElementById("channel_set").style.display = "block";
					document.getElementById("audio_set").style.display = "none";
				} else if ( event.target.value === "audio" ) {
					document.getElementById("channel_set").style.display = "none";
					document.getElementById("audio_set").style.display = "block";
				} else {
					document.getElementById("channel_set").style.display = "none";
					document.getElementById("audio_set").style.display = "none";
				}

			});
		});

		// repeat イベントの登録
		// repeat に変化があるごとに発火 > week の表示 / 非表示

		document.querySelectorAll('input[name="set_repeat"]').forEach( function(radio) {
			radio.addEventListener("change", function(event) {

				if ( event.target.checked === true ) {
					document.getElementById("week_set").style.display = "block";
				} else {
					document.getElementById("week_set").style.display = "none";
				}

			});
		});

	}

	// スケジュール関係ボタンの挙動: class によって挙動分岐

	schedule_list.addEventListener("click", async function(event) {

		//console.log(event.target.id);

		let schedule_message = document.getElementById("schedule_message");

		// add_button でスケジュール追加 UI 表示 and add_button ボタンは非表示
		// 同時に各パラメータを初期化させる

		if ( event.target.id === "add_button" ) {

			// 各パラメータを初期化

			// ID は new に戻す

			document.getElementById("edit_index").innerHTML = "new";
			document.getElementById("edit_index").dataset.index = "new";

			// time は初期化

			document.getElementById("set_time").value = "";

			// action は play に

			document.getElementById("play").checked = true;

			// チャンネルは1番目に移動

			const channel_selector = document.querySelectorAll('input[name="channel"]');
			channel_selector[0].checked = true;

			// チャンネル項目を表示

			document.getElementById("channel_set").style.display = "block";

			// repeat はチェック外す

			document.getElementById("set_repeat").checked = false;

			// week は全て解除

			const week_selector = document.querySelectorAll('input[name="week"]');

			for ( let n = 0; n < week_selector.length; n++ ) {
				week_selector[n].checked = false;
			}

			// チャンネル項目を表示

			document.getElementById("week_set").style.display = "none";

			// submit 非表示

			document.getElementById("submit_set").style.display = "none";

			// UI 表示・追加ボタン非表示

			//document.getElementById("schedule_ui").style.display = "block";
			document.getElementById("schedule_ui").classList.add("schedule_ui_visible");
			document.getElementById("add_button_box").style.display = "none";

		}

		// スケジュール UI を閉じるボタン

		if ( event.target.id === "ui_close" ) {
			//document.getElementById("schedule_ui").style.display = "none";
			document.getElementById("schedule_ui").classList.remove("schedule_ui_visible");
			document.getElementById("add_button_box").style.display = "Block";
		}

		// スケジュールの新規追加・修正

		if ( event.target.id === "schedule_set" ) {

			// 各パラメータチェック

			// id: 新規の場合は new 修正の場合は対象となるid値 (数字)

			const set_id_value = document.getElementById("edit_index").dataset.index;

			// セット時間

			let set_time_value = document.getElementById("set_time").value;

			if ( ! set_time_value ) {
				schedule_message.innerHTML = "Set the schedule time.";
				return;
			}

			// アクション

			let action_value_object = document.getElementsByName("action");

			let action_value = "";

			for (let i = 0; i < action_value_object.length; i++) {
				if ( action_value_object[i].checked ) {
					action_value = action_value_object[i].value;
				}
			}

			//console.log(action_value);

			// チャンネル

			let channel_value_object = document.getElementsByName("channel");

			let channel_value = "";

			for ( let i = 0; i < channel_value_object.length; i++ ) {
				if ( channel_value_object[i].checked ) {
					channel_value = channel_value_object[i].value;
				}
			}

			// 音声ファイル

			let audio_value_object = document.getElementsByName("audio");

			let audio_value = "";

			for ( let i = 0; i < audio_value_object.length; i++ ) {
				if ( audio_value_object[i].checked ) {
					audio_value = audio_value_object[i].value;
				}
			}

			// リピート

			let repeat_value = document.getElementById("set_repeat").checked;

			// 曜日 (リピート用)

			let week_value_object = document.getElementsByName("week");

			let week_value_array = [];

			for (let i = 0; i < week_value_object.length; i++) {
				if ( week_value_object[i].checked ) {
					week_value_array.push(week_value_object[i].value);
				}
			}

			// 送信情報の整理

			// アクションが stop または reboot の場合はチャンネル情報は不要

			if ( action_value === "stop" || action_value === "reboot" ) {
				channel_value = "";
			}

			// アクションが audio の場合はチャンネル情報へ音声ファイル情報を入れる
			// channel に URL を収納させる

			if ( action_value === "audio" ) {
				channel_value = audio_value;
			}

			// リピートが false の場合は曜日情報は不要

			if ( repeat_value === false ) {
				week_value_array = [];
			}

			// 保存処理

			const send_params = {
				id: set_id_value,
				time: set_time_value,
				action: action_value, 
				channel: channel_value,
				repeat: repeat_value,
				week: JSON.stringify(week_value_array),
				enabled: true
			};

			const query_string = new URLSearchParams(send_params).toString();

			const schedule_set_result = await modules.tol.fetch_template("./php/schedule_set.php", query_string);

			// 書込みに成功したら書き込んだバイト数が、失敗なら 0 が返って来る。

			if ( schedule_set_result !== 0 ) {
				update_schedule_audio_html();
			} else {
				modules.fnc.msg_fade_in("スケジュールの保存に失敗しました。");
			}

		}

		// スケジュールの既存情報編集のための情報セット

		if ( event.target.classList.contains("schedule_edit") === true ) {

			// スケジュール追加 UI 表示 and add_button ボタンは非表示

			document.getElementById("schedule_ui").classList.add("schedule_ui_visible");
			document.getElementById("add_button_box").style.display = "none";

			const this_index = Number(event.target.dataset.index);

			const schedule_object = await modules.tol.fetch_template("./php/schedule_get.php", "");

			// オブジェクトの中から対象IDの情報を取り出す

			const index_object = schedule_object[this_index];

			// id と data-index 変更

			document.getElementById("edit_index").innerHTML = "Index: " + this_index + " (ID: " + (this_index + 1) + ")";
			document.getElementById("edit_index").dataset.index = this_index;

			// set_time 変更

			document.getElementById("set_time").value = index_object["time"];

			// play / stop 切り替え

			document.getElementById(index_object["action"]).checked = true;

			// channel 切り替え

			let channel_value_object = document.getElementsByName("channel");

			for ( let n = 0; n < channel_value_object.length; n++ ) {
				channel_value_object[n].checked = false;
			}

			if ( index_object["channel"] !== "" ) {
				document.getElementById(index_object["channel"]).checked = true;
			}

			// action が play の場合は channel_set は表示 audio_set は非表示
			// action が audio の場合は channel_set は非表示 audio_set は表示
			// action が stop の場合は channel_set audio_set 両方非表示

			if ( index_object["action"] === "play" ) {
				document.getElementById("channel_set").style.display = "block";
				document.getElementById("audio_set").style.display = "none";
			} else if ( index_object["action"] === "audio" ) {
				document.getElementById("channel_set").style.display = "none";
				document.getElementById("audio_set").style.display = "block";
			} else {
				document.getElementById("channel_set").style.display = "none";
				document.getElementById("audio_set").style.display = "none";
			}

			// repeat

			document.getElementById("set_repeat").checked = index_object["repeat"];

			// 曜日 (リピート用)

			let week_value_object = document.getElementsByName("week");

			// repeat が true の場合は week_set は表示
			// repeat が false の場合は week_set は非表示

			if ( index_object["repeat"] === true ) {
				document.getElementById("week_set").style.display = "block";			
			} else {
				document.getElementById("week_set").style.display = "none";		
			}

			let week_value_array = [];

			// 一旦チェックを解除

			for ( let i = 0; i < week_value_object.length; i++ ) {
				week_value_object[i].checked = false;
			}

			// 一致した曜日だけチェック入れる

			const this_week_array = index_object["week"];

			for ( let d = 0; d < this_week_array.length; d++ ) {
				document.getElementById(this_week_array[d]).checked = true;
			}

			// 保存は、ここではなく if ( event.target.id === "schedule_set" ) 側で実行する
			// 保存ボタンは表示

			document.getElementById("submit_set").style.display = "Block";

			// UI を表示させる

			document.getElementById("schedule_ui").style.display = "Block";

		}

		// スケジュールの削除

		if ( event.target.classList.contains("schedule_dell") === true ) {

			const this_index = Number(event.target.dataset.index);

			if ( confirm( "スケジュールを削除します ID: " + (this_index + 1) ) ) {

				const send_params = {
					index: this_index
				};

				const query_string = new URLSearchParams(send_params).toString();
				const schedule_delete_result = await modules.tol.fetch_template("./php/schedule_delete.php", query_string);

				if ( schedule_delete_result !== 0 ) {
					update_schedule_audio_html();
				} else {
					modules.fnc.msg_fade_in("スケジュールの削除に失敗しました。");
				}

			}

		}

		// スケジュールの有効化・無効化

		if ( event.target.classList.contains("schedule_enab") === true ) {

			const this_index = Number(event.target.dataset.index);
			const this_enabled = event.target.dataset.enabled;

			let confirm_text = "";
			let enabled_value = "";

			if ( this_enabled === "true" ) {

				// 現在 true の場合 > false に変更

				confirm_text = "スケジュールを無効化します ID: " + (this_index + 1);
				enabled_value = "false";

			} else {

				// 現在 false の場合 > true に変更

				confirm_text = "スケジュールを有効化します ID: " + (this_index + 1);
				enabled_value = "true";

			}

			if ( confirm(confirm_text) ) {

				const send_params = {
					index: this_index,
					enabled: enabled_value
				};

				const query_string = new URLSearchParams(send_params).toString();
				const schedule_enabled_result = await modules.tol.fetch_template("./php/schedule_enabled.php", query_string);

				if ( schedule_enabled_result !== 0 ) {
					update_schedule_audio_html();
				} else {
					modules.fnc.msg_fade_in("スケジュールの更新に失敗しました。");
				}

			}

		}

	});

	// 音声ファイル関係ボタンの挙動: class によって挙動分岐

	list_output.addEventListener("click", async function(event) {

		// アップロードした音声ファイルの削除

		if ( event.target.classList.contains("audio_del") === true ) {

			let this_name = event.target.dataset.name;

			if ( confirm( "このファイルを削除します [" + this_name + "]" ) ) {

				const send_params = {
					file: this_name
				};

				const query_string = new URLSearchParams(send_params).toString();
				const del_result = await modules.tol.fetch_template("./php/delete_audio_file.php", query_string);

				um_output.innerHTML = del_result[1];

				if ( del_result[0] === "success" ) {
					update_schedule_audio_html();
				} else {
					um_output.innerHTML = del_result[1];
				}

			}

		}

		// アップロードした音声ファイルを再生

		if ( event.target.classList.contains("audio_play") === true ) {

			const play_btn_array = document.getElementsByClassName("audio_play");
			const del_btn_array = document.getElementsByClassName("audio_del");

			if ( list_audio_play === false ) {

				let this_name = event.target.dataset.name;

				const send_params = {
					file: decodeURI(this_name)
				};

				const play_string = new URLSearchParams(send_params).toString();
				const play_result = await modules.tol.fetch_template("./php/player_audio_play.php", play_string);

				if ( play_result === "playing" ) {

					audio_play_button_control(this_name);// 再生開始: ボタンスタイル調整

					init_play_info();// radiko 情報初期化

					// 音声ファイル再生状況監視開始

					check_audio();
					si_array.push( setInterval(check_audio, 2000) );

				} else {

					um_output.innerHTML = "[再生失敗] " + this_name;

				}

			} else {

				const result = await modules.tol.fetch_template("./php/player_stop.php", "");

				//console.log(result);

				// 再生停止: ボタンスタイル調整

				if ( result == "stopped" ) {
					audio_stop_button_control();
				} else {
					um_output.innerHTML = "*** 再生停止できませんでした ***";
				}

			}

		}

	});

	// ファイルドラッグアンドドロップの制御
	// http://iwb.jp/return-false-preventdefault-stoppropagation/

	// Drag and drop イベント
	// http://dresscording.com/blog/html5/drag_drop.html

	// ファイルドラッグアンドドロップの制御
	// http://iwb.jp/return-false-preventdefault-stoppropagation/

	drop_zone_element.addEventListener("dragover", function(event) {

		event.stopPropagation();
		event.preventDefault();
		event.dataTransfer.dropEffect = "copy";// 明示的にこれは copy であることを示します。

		drop_zone_element.classList.add("drag_and_drop");// クラス追加

	}, false);

	drop_zone_element.addEventListener("dragleave", function(event) {

		drop_zone_element.classList.remove("drag_and_drop");// クラス削除

	}, false);

	drop_zone_element.addEventListener("drop", async function(event) {

		event.stopPropagation();// イベントの伝搬を止める
		event.preventDefault();// イベント本来の一般的動作止める

		const target_files = event.dataTransfer.files;// ファイルリストオブジェクト

		drop_zone_element.classList.remove("drag_and_drop");// クラス削除

		// 複数ファイル ajax アップロード処理

		const upload_result = await modules.tol.fetch_upload(target_files, um_output);

		// 処理が終わったらスケジュールと音声ファイル関係の表示を更新

		if ( upload_result.length > 0 ) {
			update_schedule_audio_html();
		}

	}, false);

	// スーパーリロード

	document.getElementById("super_reload").addEventListener("click", function() {
		location.reload(true);
	}, false);

</script>

</body>
</html>